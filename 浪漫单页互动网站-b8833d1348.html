<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>致亦婷/eating</title>
    <script src="https://cdn.tailwindcss.com/3.3.3"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #ffc0cb 0%, #ffb3d9 50%, #ffc0cb 100%);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            position: relative;
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
        }
        
        /* 顶部导航 */
        .top-nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 40px;
            z-index: 100;
        }
        
        .site-title {
            font-size: 28px;
            font-weight: bold;
            background: linear-gradient(135deg, #ff1493, #ff69b4, #ff1493);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: 2px;
            text-shadow: 0 2px 10px rgba(255, 20, 147, 0.3);
        }
        
        .lang-switch {
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #ff69b4;
            border-radius: 25px;
            padding: 8px 20px;
            font-size: 16px;
            font-weight: bold;
            color: #ff1493;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 105, 180, 0.3);
        }
        
        .lang-switch:hover {
            background: #ff69b4;
            color: white;
            transform: scale(1.05);
        }
        
        #background-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        
        #main-container {
            position: relative;
            z-index: 1;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .wish-button {
            background: linear-gradient(135deg, #ff69b4, #ff1493);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 20px 48px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 10px 25px rgba(255, 20, 147, 0.4),
                        0 0 40px rgba(255, 105, 180, 0.3);
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            z-index: 10;
            position: relative;
            overflow: hidden;
        }
        
        .wish-button::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transform: rotate(45deg);
            animation: shine 3s infinite;
        }
        
        @keyframes shine {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
        }
        
        .wish-button:hover {
            transform: scale(1.1) translateY(-2px);
            box-shadow: 0 15px 35px rgba(255, 20, 147, 0.6),
                        0 0 60px rgba(255, 105, 180, 0.5);
        }
        
        .wish-button:active {
            transform: scale(0.98);
        }
        
        .wish-popup {
            position: absolute;
            background-color: white;
            border-radius: 16px;
            padding: 20px 28px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
            animation: popup-appear 0.5s ease-out forwards;
            z-index: 5;
            max-width: 220px;
            min-width: 180px;
            text-align: center;
            word-wrap: break-word;
            font-size: 18px;
            font-weight: 600;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .wish-popup:hover {
            z-index: 1000 !important;
            transform: scale(1.15) rotate(2deg);
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.35);
        }
        
        @keyframes popup-appear {
            from {
                opacity: 0;
                transform: scale(0);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        .love-button {
            background: linear-gradient(135deg, #ff1493, #ff69b4);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 24px 56px;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 12px 30px rgba(255, 20, 147, 0.6),
                        0 0 50px rgba(255, 105, 180, 0.4);
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            z-index: 20;
            display: none;
            animation: heartbeat 1.5s infinite;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        @keyframes heartbeat {
            0%, 100% { transform: scale(1); }
            10%, 30% { transform: scale(1.05); }
            20% { transform: scale(0.95); }
        }
        
        .love-button:hover {
            transform: scale(1.15) translateY(-3px);
            box-shadow: 0 18px 40px rgba(255, 20, 147, 0.8),
                        0 0 70px rgba(255, 105, 180, 0.6);
            animation: none;
        }
        
        #particles-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: black;
            display: none;
            z-index: 30;
        }
        
        #particles-canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <!-- 顶部导航 -->
    <div class="top-nav">
        <div class="site-title">致 eating / 亦婷</div>
        <button class="lang-switch" onclick="toggleLanguage()">中 / EN</button>
    </div>
    
    <canvas id="background-canvas"></canvas>
    
    <div id="main-container">
        <button id="wishButton" class="wish-button">
            <i class="fas fa-heart mr-2"></i>祝愿
        </button>
        
        <button id="loveButton" class="love-button">
            <i class="fas fa-heart mr-2"></i>我也喜欢你
        </button>
    </div>
    
    <div id="particles-container">
        <canvas id="particles-canvas"></canvas>
    </div>
    
    <script>
        // 背景爱心动画
        const backgroundCanvas = document.getElementById('background-canvas');
        const bgCtx = backgroundCanvas.getContext('2d');
        
        // 设置canvas尺寸
        function resizeCanvas() {
            backgroundCanvas.width = window.innerWidth;
            backgroundCanvas.height = window.innerHeight;
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // 爱心类
        class Heart {
            constructor() {
                this.x = Math.random() * backgroundCanvas.width;
                this.y = Math.random() * backgroundCanvas.height;
                this.size = Math.random() * 20 + 10;
                this.speedX = (Math.random() - 0.5) * 0.5;
                this.speedY = (Math.random() - 0.5) * 0.5;
                this.opacity = Math.random() * 0.5 + 0.2;
            }
            
            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                
                // 边界检测
                if (this.x < -this.size) this.x = backgroundCanvas.width + this.size;
                if (this.x > backgroundCanvas.width + this.size) this.x = -this.size;
                if (this.y < -this.size) this.y = backgroundCanvas.height + this.size;
                if (this.y > backgroundCanvas.height + this.size) this.y = -this.size;
            }
            
            draw() {
                bgCtx.save();
                bgCtx.globalAlpha = this.opacity;
                bgCtx.fillStyle = '#ff69b4';
                
                // 优化后的爱心绘制，使用参数方程生成平滑形状
                bgCtx.beginPath();
                const x = this.x;
                const y = this.y;
                const scale = this.size / 16; // 调整比例以匹配标准爱心方程
                
                for (let i = 0; i <= 360; i += 5) { // 使用更少的点以优化性能
                    const t = i * Math.PI / 180;
                    const hx = 16 * Math.pow(Math.sin(t), 3);
                    const hy = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                    if (i === 0) {
                        bgCtx.moveTo(x + hx * scale, y - hy * scale);
                    } else {
                        bgCtx.lineTo(x + hx * scale, y - hy * scale);
                    }
                }
                
                bgCtx.closePath();
                bgCtx.fill();
                bgCtx.restore();
            }
        }
        
        // 创建爱心数组(减少数量优化性能)
        const hearts = [];
        for (let i = 0; i < 30; i++) {
            hearts.push(new Heart());
        }
        
        // 动画循环
        function animateBackground() {
            bgCtx.clearRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
            
            for (const heart of hearts) {
                heart.update();
                heart.draw();
            }
            
            requestAnimationFrame(animateBackground);
        }
        
        animateBackground();
        
        // 核心交互功能
        const wishButton = document.getElementById('wishButton');
        const loveButton = document.getElementById('loveButton');
        const mainContainer = document.getElementById('main-container');
        const particlesContainer = document.getElementById('particles-container');
        
        // 中英文祝愿语数组
        const wishesData = {
            zh: [
                "愿你永远开心", "爱你一万年", "你是我的唯一", "余生请多指教", 
                "永远在一起", "我喜欢你", "每一天都爱你", "你是最棒的",
                "愿你幸福安康", "心有灵犀一点通", "此情不渝", "执子之手与子偕老",
                "一生一世一双人", "相濡以沫", "永浴爱河", "爱的告白",
                "浪漫满屋", "甜蜜时光", "心跳加速", "如胶似漆",
                "一往情深", "海枯石烂", "天荒地老", "比翼双飞"
            ],
            //这是真的啦
            en: [
                "hopefully you're happy", "love me forever", "you're my only", "I'm gonna be your best friend", 
                "forever and ever", "I like you", "everyday I love you", "you're the best",
                "I hope you're healthy", "I'm feeling you", "this love is true", "I'm gonna be your man",
                "one and only one", "love and peace", "love's a river", "love's a confession",
                "love's a party", "love's a ball", "love's a thrill", "love's a date",
                "love's deep", "love's true", "love's fast", "love's a plane"
            ]
        };
        
        let currentLang = 'zh'; // 默认中文
        let wishes = wishesData[currentLang];
        
        // 语言切换函数
        function toggleLanguage() {
            currentLang = currentLang === 'zh' ? 'en' : 'zh';
            wishes = wishesData[currentLang];
            
            // 更新按钮文本
            const wishButton = document.getElementById('wishButton');
            const loveButton = document.getElementById('loveButton');
            if (currentLang === 'zh') {
                wishButton.innerHTML = '<i class="fas fa-heart mr-2"></i>祝愿';
                loveButton.innerHTML = '<i class="fas fa-heart mr-2"></i>我也喜欢你';
            } else {
                wishButton.innerHTML = '<i class="fas fa-heart mr-2"></i>Wish';
                loveButton.innerHTML = '<i class="fas fa-heart mr-2"></i>I like you too';
            }
            
            // 更新所有已生成的弹窗文本
            const allPopups = document.querySelectorAll('.wish-popup');
            allPopups.forEach(popup => {
                const newWish = wishes[Math.floor(Math.random() * wishes.length)];
                popup.textContent = newWish;
            });
        }
        
        let popupCount = 0;
        const maxPopups = 100; // 最大弹窗数量
        const additionalPopups = 150; // 额外随机铺满的弹窗数量
        
        // 生成爱心形状的点
        function generateHeartShapePoints(numPoints) {
            const points = [];
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            const radius = Math.min(window.innerWidth, window.innerHeight) * 0.4;
            
            for (let i = 0; i < numPoints; i++) {
                const t = (i / numPoints) * Math.PI * 2;
                // 爱心参数方程
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                
                // 缩放并平移
                const scaledX = centerX + x * (radius / 16);
                const scaledY = centerY - y * (radius / 16);
                
                points.push({x: scaledX, y: scaledY});
            }
            
            return points;
        }
        
        // 点击"祝愿你"按钮
        wishButton.addEventListener('click', function() {
            this.style.display = 'none';
            
            const heartPoints = generateHeartShapePoints(maxPopups);
            let currentIndex = 0;
            
            // 逐渐生成弹窗
            const popupInterval = setInterval(() => {
                if (currentIndex >= maxPopups) {
                    clearInterval(popupInterval);
                    // 开始随机铺满屏幕
                    setTimeout(() => {
                        fillScreenWithPopups(heartPoints);
                    }, 500);
                    return;
                }
                
                const point = heartPoints[currentIndex];
                createWishPopup(point.x, point.y);
                currentIndex++;
            }, 50); // 每50ms生成一个弹窗
        });
        
        // 创建祝愿弹窗
        function createWishPopup(x, y) {
            const popup = document.createElement('div');
            popup.classList.add('wish-popup');
            
            // 随机选择祝愿语
            const wish = wishes[Math.floor(Math.random() * wishes.length)];
            popup.textContent = wish;
            
            // 随机颜色
            const colors = ['#ff69b4', '#ff1493', '#db7093', '#ff85a2', '#ffb6c1'];
            const color = colors[Math.floor(Math.random() * colors.length)];
            popup.style.backgroundColor = color;
            popup.style.color = 'white';
            
            // 设置位置
            popup.style.left = `${x}px`;
            popup.style.top = `${y}px`;
            
            // 添加到容器
            mainContainer.appendChild(popup);
            popupCount++;
        }
        
        // 随机铺满屏幕(保留中间爱心区域)
        function fillScreenWithPopups(heartPoints) {
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            const heartRadius = Math.min(window.innerWidth, window.innerHeight) * 0.4;
            
            let addedCount = 0;
            const fillInterval = setInterval(() => {
                if (addedCount >= additionalPopups) {
                    clearInterval(fillInterval);
                    // 显示"我也喜欢你"按钮
                    loveButton.style.display = 'block';
                    return;
                }
                
                // 生成随机位置,确保不在爱心区域内
                let x, y, attempts = 0;
                do {
                    x = Math.random() * window.innerWidth;
                    y = Math.random() * window.innerHeight;
                    const dx = x - centerX;
                    const dy = y - centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > heartRadius + 50) {
                        break;
                    }
                    attempts++;
                } while (attempts < 20);
                
                if (attempts < 20) {
                    createWishPopup(x, y);
                    addedCount++;
                }
            }, 30);
        }
        
        // 点击"我也喜欢你"按钮
        loveButton.addEventListener('click', function() {
            // 隐藏所有元素
            mainContainer.style.display = 'none';
            
            // 显示粒子容器
            particlesContainer.style.display = 'block';
            
            // 启动粒子效果
            initParticles();
        });
        
        // 融合效果：立体悬浮粒子爱心 + 背景烟花
        function initParticles() {
            const particlesCanvas = document.getElementById('particles-canvas');
            const pCtx = particlesCanvas.getContext('2d');
            
            particlesCanvas.width = window.innerWidth;
            particlesCanvas.height = window.innerHeight;
            
            window.addEventListener('resize', function() {
                particlesCanvas.width = window.innerWidth;
                particlesCanvas.height = window.innerHeight;
                initParticleSystem();
            });
            
            // 立体爱心粒子 - 优化性能
            let heartParticles = [];
            const heartParticleCount = 2500; // 适度减少粒子数量
            let time = 0;
            let rotationAngleY = 0;
            let rotationAngleX = 0;
            
            // 性能优化：使用离屏Canvas
            const offscreenCanvas = document.createElement('canvas');
            const offscreenCtx = offscreenCanvas.getContext('2d');
            let useOffscreen = true;
            
            // 烟花系统
            let fireworks = [];
            let fireworkParticles = [];
            
            class Firework {
                constructor() {
                    // 从底部随机位置发射
                    this.x = Math.random() * particlesCanvas.width * 0.6 + particlesCanvas.width * 0.2;
                    this.y = particlesCanvas.height;
                    // 目标位置避开中心爱心区域
                    const centerX = particlesCanvas.width / 2;
                    const centerY = particlesCanvas.height / 2;
                    const minDist = 250; // 离中心最小距离
                    
                    do {
                        this.targetX = Math.random() * particlesCanvas.width;
                        this.targetY = Math.random() * particlesCanvas.height * 0.6;
                        const dx = this.targetX - centerX;
                        const dy = this.targetY - centerY;
                        this.distFromCenter = Math.sqrt(dx * dx + dy * dy);
                    } while (this.distFromCenter < minDist);
                    
                    this.speed = Math.random() * 2 + 4;
                    this.angle = Math.atan2(this.targetY - this.y, this.targetX - this.x);
                    this.color = `hsl(${Math.random() * 60 + 300}, 100%, ${Math.random() * 20 + 50}%)`;
                    this.trail = [];
                }
                
                update() {
                    // 添加尾迹
                    this.trail.push({x: this.x, y: this.y});
                    if (this.trail.length > 8) this.trail.shift();
                    
                    const dx = this.targetX - this.x;
                    const dy = this.targetY - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > this.speed) {
                        this.x += Math.cos(this.angle) * this.speed;
                        this.y += Math.sin(this.angle) * this.speed;
                        return false;
                    } else {
                        return true;
                    }
                }
                
                draw() {
                    // 绘制尾迹
                    pCtx.strokeStyle = this.color;
                    pCtx.lineWidth = 2;
                    pCtx.beginPath();
                    for (let i = 0; i < this.trail.length; i++) {
                        const point = this.trail[i];
                        if (i === 0) {
                            pCtx.moveTo(point.x, point.y);
                        } else {
                            pCtx.lineTo(point.x, point.y);
                        }
                    }
                    pCtx.stroke();
                    
                    // 绘制主体
                    pCtx.beginPath();
                    pCtx.arc(this.x, this.y, 4, 0, Math.PI * 2);
                    pCtx.fillStyle = this.color;
                    pCtx.shadowBlur = 10;
                    pCtx.shadowColor = this.color;
                    pCtx.fill();
                    pCtx.shadowBlur = 0;
                }
            }
            
            class FireworkParticle {
                constructor(x, y, color) {
                    this.x = x;
                    this.y = y;
                    this.size = Math.random() * 3 + 1;
                    // 更广的发散范围
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 8 + 2;
                    this.speedX = Math.cos(angle) * speed;
                    this.speedY = Math.sin(angle) * speed;
                    this.color = color;
                    this.alpha = 1;
                    this.decay = Math.random() * 0.012 + 0.008;
                    this.gravity = 0.15;
                }
                
                update() {
                    this.speedY += this.gravity;
                    this.speedX *= 0.98; // 空气阻力
                    this.speedY *= 0.98;
                    this.x += this.speedX;
                    this.y += this.speedY;
                    this.alpha -= this.decay;
                }
                
                draw() {
                    pCtx.save();
                    pCtx.globalAlpha = this.alpha;
                    pCtx.beginPath();
                    pCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    pCtx.fillStyle = this.color;
                    pCtx.shadowBlur = 15;
                    pCtx.shadowColor = this.color;
                    pCtx.fill();
                    pCtx.restore();
                }
            }
            
            function createFireworkParticles(x, y, color) {
                // 增加爆炸粒子数量
                for (let i = 0; i < 80; i++) {
                    fireworkParticles.push(new FireworkParticle(x, y, color));
                }
            }
            
            function initParticleSystem() {
                heartParticles = [];
                
                // 设置离屏Canvas尺寸
                offscreenCanvas.width = particlesCanvas.width;
                offscreenCanvas.height = particlesCanvas.height;
                
                // 优化的3D爱心粒子生成算法
                const radius = Math.min(particlesCanvas.width, particlesCanvas.height) * 0.3;
                
                // 使用更高效的体积采样
                for (let i = 0; i < heartParticleCount; i++) {
                    const t = Math.random() * Math.PI * 2;
                    const u = Math.random(); // 径向因子
                    const v = Math.random(); // 深度因子
                    
                    // 爱心参数方程
                    const x = 16 * Math.pow(Math.sin(t), 3);
                    const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    
                    // 体积填充
                    const r = Math.pow(u, 0.33); // 立方根分布使粒子更均匀
                    const z = (v - 0.5) * 2 * 100 * r; // Z轴也随径向缩放
                    
                    heartParticles.push({
                        x: Math.random() * particlesCanvas.width,
                        y: Math.random() * particlesCanvas.height,
                        size: Math.random() * 2.5 + 1,
                        targetX: x * r * (radius / 16),
                        targetY: -y * r * (radius / 16),
                        targetZ: z,
                        alpha: 0.7 + Math.random() * 0.3,
                        // 钻石材质效果 - 多层次颜色
                        hue: 320 + Math.random() * 40,
                        brightness: 50 + Math.random() * 40,
                        saturation: 80 + Math.random() * 20,
                        floatOffset: Math.random() * Math.PI * 2,
                        floatSpeed: Math.random() * 0.01 + 0.005,
                        // 钻石闪烁效果
                        sparklePhase: Math.random() * Math.PI * 2,
                        sparkleSpeed: Math.random() * 0.05 + 0.02,
                        // 缓存渲染状态
                        renderCache: {
                            lastX: 0,
                            lastY: 0,
                            needsUpdate: true
                        }
                    });
                }
                
                // 立即开始烟花效果
                startFireworks();
                
                animateParticles();
            }
            

            
            // 烟花启动函数
            function startFireworks() {
                setInterval(() => {
                    if (Math.random() < 0.5) {
                        fireworks.push(new Firework());
                    }
                }, 800);
            }
            
            function animateParticles() {
                time++;
                rotationAngleY += 0.008;
                rotationAngleX = Math.sin(time * 0.001) * 0.3;
                
                // 渐变背景
                const gradient = pCtx.createRadialGradient(
                    particlesCanvas.width / 2, particlesCanvas.height / 2, 0,
                    particlesCanvas.width / 2, particlesCanvas.height / 2, particlesCanvas.width / 2
                );
                gradient.addColorStop(0, '#0a0015');
                gradient.addColorStop(1, '#1a0030');
                pCtx.fillStyle = gradient;
                pCtx.fillRect(0, 0, particlesCanvas.width, particlesCanvas.height);
                
                const centerX = particlesCanvas.width / 2;
                const centerY = particlesCanvas.height / 2;
                
                // 烟花效果 - 持续运行
                // 更新烟花
                for (let i = fireworks.length - 1; i >= 0; i--) {
                    fireworks[i].draw();
                    if (fireworks[i].update()) {
                        createFireworkParticles(fireworks[i].x, fireworks[i].y, fireworks[i].color);
                        fireworks.splice(i, 1);
                    }
                }
                
                // 更新烟花粒子
                for (let i = fireworkParticles.length - 1; i >= 0; i--) {
                    fireworkParticles[i].update();
                    fireworkParticles[i].draw();
                    if (fireworkParticles[i].alpha <= 0) {
                        fireworkParticles.splice(i, 1);
                    }
                }
                
                // 性能优化：预计算共用值
                const cosY = Math.cos(rotationAngleY);
                const sinY = Math.sin(rotationAngleY);
                const cosX = Math.cos(rotationAngleX);
                const sinX = Math.sin(rotationAngleX);
                
                // 绘制钻石般的立体爱心粒子 - 优化版
                let sortedParticles = heartParticles.slice().sort((a, b) => {
                    let zA = a.targetX * sinY + a.targetZ * cosY;
                    let zB = b.targetX * sinY + b.targetZ * cosY;
                    return zA - zB;
                });
                
                // 性能优化：批量设置shadowBlur
                pCtx.shadowBlur = 18;
                
                // 性能优化：每隔一帧跳过部分粒子的复杂渲染
                const skipComplexRender = time % 2 === 0;
                
                for (let i = 0; i < sortedParticles.length; i++) {
                    const particle = sortedParticles[i];
                    
                    // 3D旋转变换 - 使用预计算的值
                    let x = particle.targetX;
                    let y = particle.targetY;
                    let z = particle.targetZ;
                    
                    let rotatedX = x * cosY - z * sinY;
                    let rotatedZ = x * sinY + z * cosY;
                    
                    let rotatedY = y * cosX - rotatedZ * sinX;
                    rotatedZ = y * sinX + rotatedZ * cosX;
                    
                    // 悬浮效果
                    particle.floatOffset += particle.floatSpeed;
                    const floatY = Math.sin(particle.floatOffset) * 5;
                    
                    const finalX = centerX + rotatedX;
                    const finalY = centerY + rotatedY + floatY;
                    
                    // 缓动移动
                    const dx = finalX - particle.x;
                    const dy = finalY - particle.y;
                    particle.x += dx * 0.08;
                    particle.y += dy * 0.08;
                    
                    // 性能优化：检查是否需要更新
                    const moved = Math.abs(particle.x - particle.renderCache.lastX) > 0.5 ||
                                  Math.abs(particle.y - particle.renderCache.lastY) > 0.5;
                    
                    if (!moved && !particle.renderCache.needsUpdate) continue;
                    
                    particle.renderCache.lastX = particle.x;
                    particle.renderCache.lastY = particle.y;
                    particle.renderCache.needsUpdate = false;
                    
                    // 透视效果
                    const perspective = 1 + rotatedZ / 600;
                    const size = particle.size * perspective;
                    const alpha = particle.alpha * Math.max(0.4, Math.min(1, perspective));
                    
                    // 钻石闪烁效果
                    particle.sparklePhase += particle.sparkleSpeed;
                    const sparkle = (Math.sin(particle.sparklePhase) + 1) * 0.5;
                    const brightness = particle.brightness + sparkle * 30;
                    
                    // 钻石多彩效果 - 根据角度变化颜色
                    const angleEffect = (rotationAngleY * 50) % 60;
                    const hue = (particle.hue + angleEffect) % 360;
                    
                    // 性能优化：简化渲染（跳帧时使用简单渲染）
                    if (skipComplexRender && i % 3 !== 0) {
                        // 简单渲染
                        pCtx.fillStyle = `hsla(${hue}, ${particle.saturation}%, ${brightness}%, ${alpha})`;
                        pCtx.beginPath();
                        pCtx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
                        pCtx.fill();
                    } else {
                        // 完整钻石效果渲染
                        pCtx.shadowColor = `hsla(${hue}, ${particle.saturation}%, ${brightness}%, ${alpha * 0.6})`;
                        
                        // 主体 - 渐变效果
                        const gradient = pCtx.createRadialGradient(
                            particle.x, particle.y, 0,
                            particle.x, particle.y, size
                        );
                        gradient.addColorStop(0, `hsla(${hue}, 100%, ${brightness + 20}%, ${alpha})`);
                        gradient.addColorStop(0.5, `hsla(${hue}, ${particle.saturation}%, ${brightness}%, ${alpha})`);
                        gradient.addColorStop(1, `hsla(${hue}, ${particle.saturation - 20}%, ${brightness - 20}%, ${alpha * 0.6})`);
                        
                        pCtx.fillStyle = gradient;
                        pCtx.beginPath();
                        pCtx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
                        pCtx.fill();
                        
                        // 高光点
                        if (sparkle > 0.7) {
                            pCtx.fillStyle = `rgba(255, 255, 255, ${(sparkle - 0.7) * alpha})`;
                            pCtx.beginPath();
                            pCtx.arc(particle.x - size * 0.3, particle.y - size * 0.3, size * 0.3, 0, Math.PI * 2);
                            pCtx.fill();
                        }
                    }
                }
                
                pCtx.shadowBlur = 0;
                
                requestAnimationFrame(animateParticles);
            }
            
            initParticleSystem();
        }

    </script>
</body>
</html>
